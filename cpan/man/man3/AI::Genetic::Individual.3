.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Genetic::Individual 3"
.TH Genetic::Individual 3 "2005-03-03" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AI::Genetic::Individual \- Base class for AI::Genetic Individuals.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See AI::Genetic.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package implements the base class for all AI::Genetic individuals.
It provides basic methods required by AI::Genetic for correct evolution.
Furthermore, it can be very easily used as a base class for additional
types of individuals. AI::Genetic comes with three individual types that
inherit from this class. These are \fIIndBitVector\fR, \fIIndListVector\fR,
and \fIIndRangeVector\fR.
.PP
See \*(L"\s-1CREATING\s0 \s-1YOUR\s0 \s-1OWN\s0 \s-1INDIVIDUAL\s0 \s-1CLASS\s0\*(R" for more details.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
The following methods are accessible publicly. They are not meant to
be over-ridden:
.ie n .IP "\fI\fI$individual\fI\fR                \->\fBnew(options)\fR" 4
.el .IP "\fI\f(CI$individual\fI\fR                \->\fBnew(options)\fR" 4
.IX Item "$individual                ->new(options)"
.PD 0
.IP "\fIAI::Genetic::IndBitVector\fR  \->\fBnew(options)\fR" 4
.IX Item "AI::Genetic::IndBitVector  ->new(options)"
.IP "\fIAI::Genetic::IndListVector\fR \->\fBnew(options)\fR" 4
.IX Item "AI::Genetic::IndListVector ->new(options)"
.IP "\fIAI::Genetic::IndRangeVector\fR\->\fBnew(options)\fR" 4
.IX Item "AI::Genetic::IndRangeVector->new(options)"
.PD
This is the default constructor. It can be called as an instance method or
as a class method. In both cases it returns a new individual of
the proper type.
.Sp
If called as an instance method, it expects one argument
which defines the genes of the individual. All other attributes, like
fitness function, class, etc, will be copied from the calling
instance.
.Sp
If called as a class method, then it calls \fI\fInewSpecific()\fI\fR. See below
for details.
.ie n .IP "\fI\fI$individual\fI\fR\->\fBfitness(?anon_sub?)\fR" 4
.el .IP "\fI\f(CI$individual\fI\fR\->\fBfitness(?anon_sub?)\fR" 4
.IX Item "$individual->fitness(?anon_sub?)"
This method is used to set/query the anonymous subroutine used to
calculate the individual's fitness. If an argument is given, it expects
a subroutine reference which will be set as the fitness subroutine. In
either case, it'll return the fitness sub ref.
.ie n .IP "\fI\fI$individual\fI\fR\->\fB\f(BIscore()\fB\fR" 4
.el .IP "\fI\f(CI$individual\fI\fR\->\fB\f(BIscore()\fB\fR" 4
.IX Item "$individual->score()"
This method returns the fitness score of the individual. If the score has
never been calculated before, then the fitness function is executed and
the score saved. Subsequent calls to \fIscore()\fR will return the cached value.
.ie n .IP "\fI\fI$individual\fI\fR\->\fB\f(BIresetScore()\fB\fR" 4
.el .IP "\fI\f(CI$individual\fI\fR\->\fB\f(BIresetScore()\fB\fR" 4
.IX Item "$individual->resetScore()"
This method resets the score of the individual such that a subsequent call
to \fI\fIscore()\fI\fR will result in the execution of the fitness sub.
.PP
The following methods are meant to be over-ridden by any class that
inherits from AI::Genetic::Individual:
.ie n .IP "\fI\fI$individual\fI\fR\->\fBnewRandom(options)\fR" 4
.el .IP "\fI\f(CI$individual\fI\fR\->\fBnewRandom(options)\fR" 4
.IX Item "$individual->newRandom(options)"
This method returns an individual with random genes. It is called with the
arguments supplied to \fI\fIAI::Genetic::init()\fI\fR as explained in
"\fI\f(CI$ga\fI\fR\->\fBinit\fR(\fIinitArgs\fR)" in AI::Genetic.
.ie n .IP "\fI\fI$individual\fI\fR\->\fBnewSpecific(options)\fR" 4
.el .IP "\fI\f(CI$individual\fI\fR\->\fBnewSpecific(options)\fR" 4
.IX Item "$individual->newSpecific(options)"
This method returns an individual with the given genetic makeup. The
options depend on the type of individual:
.RS 4
.IP "o bitvector" 4
.IX Item "o bitvector"
One argument is expected which is an anonymous list of genes:
.Sp
.Vb 1
\&  AI::Genetic::IndBitVector\->new([0, 1, 1, 0, 1, 0]);
.Ve
.IP "o listvector" 4
.IX Item "o listvector"
Two arguments are expected. The first is an anonymous list of
genes, the second is an anonymous list of lists of possible gene values,
similar to the argument of \fInewRandom\fR.
.Sp
.Vb 7
\&  AI::Genetic::IndListVector\->new(
\&    [qw/red medium fat/],   # genes
\&    [  # possible values
\&     [qw/red blue green/],
\&     [qw/big medium small/],
\&     [qw/very_fat fat fit thin very_thin/],
\&    ]);
.Ve
.IP "o rangevector" 4
.IX Item "o rangevector"
Two arguments are expected. The first is an anonymous list of
genes, the second is an anonymous list of lists of possible gene values,
similar to the argument of \fInewRandom\fR.
.Sp
.Vb 7
\&  AI::Genetic::IndListVector\->new(
\&    [3, 14, 4],   # genes
\&    [   # possible values
\&     [1, 5],
\&     [0, 20],
\&     [4, 9],
\&    ]);
.Ve
.RE
.RS 4
.RE
.ie n .IP "\fI\fI$individual\fI\fR\->\fB\f(BIgenes()\fB\fR" 4
.el .IP "\fI\f(CI$individual\fI\fR\->\fB\f(BIgenes()\fB\fR" 4
.IX Item "$individual->genes()"
In list context, returns a list of genes. In scalar context returns an
anonymous list of the genes.
.PP
Other useful non-generic methods:
.ie n .IP "\fI\fI$listVectorInd\fI\fR\->\fB\f(BIlists()\fB\fR" 4
.el .IP "\fI\f(CI$listVectorInd\fI\fR\->\fB\f(BIlists()\fB\fR" 4
.IX Item "$listVectorInd->lists()"
This method returns an anonymous list of lists which describes the possible
value of each gene for the given AI::Genetic::IndListVector individual. This
is the same argument passed to \fI\fInewRandom()\fI\fR.
.ie n .IP "\fI\fI$rangeVectorInd\fI\fR\->\fB\f(BIranges()\fB\fR" 4
.el .IP "\fI\f(CI$rangeVectorInd\fI\fR\->\fB\f(BIranges()\fB\fR" 4
.IX Item "$rangeVectorInd->ranges()"
This method returns an anonymous list of lists which describes the possible
range of each gene for the given AI::Genetic::IndRangeVector individual. This
is the same argument passed to \fI\fInewRandom()\fI\fR.
.SH "CREATING YOUR OWN INDIVIDUAL CLASS"
.IX Header "CREATING YOUR OWN INDIVIDUAL CLASS"
Creating your own individual class is easy. All you have to do is inherit from
AI::Genetic::Individual and override the \fI\fInewRandom()\fI\fR, \fInewSpecific\fR, and
\&\fI\fIgenes()\fI\fR methods to conform with the documentation above. Specifically, the
arguments to i<newRandom> and \fInewSpecific\fR have to match what \fI\fIAI::Genetic::init()\fI\fR
expects as arguments. You can also define any additional methods that you might
require in your own custom-made strategies.
.PP
Note that in order for your own individual class to be useful, you have to define
your own custom strategy that knows how to evolve such individuals. Conceptually,
this should be very simple.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Ala Qumsieh \fIaqumsieh@cpan.org\fR.
.SH "COPYRIGHTS"
.IX Header "COPYRIGHTS"
(c) 2003,2004 Ala Qumsieh. All rights reserved.
This module is distributed under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 248:" 4
.IX Item "Around line 248:"
=cut found outside a pod block.  Skipping to next block.

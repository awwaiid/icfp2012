.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Genetic 3"
.TH Genetic 3 "2007-05-11" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AI::Genetic \- A pure Perl genetic algorithm implementation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&    use AI::Genetic;
\&    my $ga = new AI::Genetic(
\&        \-fitness    => \e&fitnessFunc,
\&        \-type       => \*(Aqbitvector\*(Aq,
\&        \-population => 500,
\&        \-crossover  => 0.9,
\&        \-mutation   => 0.01,
\&        \-terminate  => \e&terminateFunc,
\&       );
\&
\&     $ga\->init(10);
\&     $ga\->evolve(\*(AqrouletteTwoPoint\*(Aq, 100);
\&     print "Best score = ", $ga\->getFittest\->score, ".\en";
\&
\&     sub fitnessFunc {
\&         my $genes = shift;
\&
\&         my $fitness;
\&         # assign a number to $fitness based on the @$genes
\&         # ...
\&
\&         return $fitness;
\&      }
\&
\&      sub terminateFunc {
\&         my $ga = shift;
\&
\&         # terminate if reached some threshold.
\&         return 1 if $ga\->getFittest\->score > $THRESHOLD;
\&         return 0;
\&      }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a Genetic Algorithm (\s-1GA\s0) in pure Perl.
Other Perl modules that achieve the same thing (perhaps better,
perhaps worse) do exist. Please check \s-1CPAN\s0. I mainly wrote this
module to satisfy my own needs, and to learn something about GAs
along the way.
.PP
\&\fB\s-1PLEASE\s0 \s-1NOTE:\s0\fR As of v0.02, AI::Genetic has been re-written from
scratch to be more modular and expandable. To achieve this, I had
to modify the \s-1API\s0, so it is not backward-compatible with v0.01.
As a result, I do not plan on supporting v0.01.
.PP
I will not go into the details of GAs here, but here are the
bare basics. Plenty of information can be found on the web.
.PP
In a \s-1GA\s0, a population of individuals compete for survival. Each
individual is designated by a set of genes that define its
behaviour. Individuals that perform better (as defined by the
fitness function) have a higher chance of mating with other
individuals. When two individuals mate, they swap some of
their genes, resulting in an individual that has properties
from both of its \*(L"parents\*(R". Every now and then, a mutation
occurs where some gene randomly changes value, resulting in
a different individual. If all is well defined, after a few
generations, the population should converge on a \*(L"good-enough\*(R"
solution to the problem being tackled.
.PP
A \s-1GA\s0 implementation runs for a discrete number of time steps
called \fIgenerations\fR. What happens during each generation can
vary greatly depending on the strategy being used (See 
\&\*(L"\s-1STRATEGIES\s0\*(R" for more info).
Typically, a variation of the following happens at
each generation:
.IP "\fB1. Selection\fR" 4
.IX Item "1. Selection"
Here the performance of all the individuals is evaluated
based on the fitness function, and each is given a specific
fitness value. The higher the value, the bigger the chance
of an individual passing its genes on in future generations
through mating (crossover).
.IP "\fB2. Crossover\fR" 4
.IX Item "2. Crossover"
Here, individuals selected are randomly paired up for
crossover (aka \fIsexual reproduction\fR). This is further
controlled by the crossover rate specified and may result in
a new offspring individual that contains genes common to
both parents. New individuals are injected into the current
population.
.IP "\fB3. Mutation\fR" 4
.IX Item "3. Mutation"
In this step, each individual is given the chance to mutate
based on the mutation probability specified. If an individual
is to mutate, each of its genes is given the chance to randomly
switch its value to some other state.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
Here are the public methods.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBnew\fR(\fIoptions\fR)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBnew\fR(\fIoptions\fR)" 4
.IX Item "$ga->new(options)"
This is the constructor. It accepts options in the form of
hash-value pairs. These are:
.RS 4
.IP "\fB\-population\fR" 8
.IX Item "-population"
This defines the size of the population, i.e. how many individuals
to simultaneously exist at each generation. Defaults to 100.
.IP "\fB\-crossover\fR" 8
.IX Item "-crossover"
This defines the crossover rate. Defaults to 0.95.
.IP "\fB\-mutation\fR" 8
.IX Item "-mutation"
This defines the mutation rate. Defaults to 0.05.
.IP "\fI\-fitness\fR" 8
.IX Item "-fitness"
This defines a fitness function. It expects a reference to a subroutine.
More details are given in \*(L"\s-1FITNESS\s0 \s-1FUNCTION\s0\*(R".
.IP "\fI\-type\fR" 8
.IX Item "-type"
This defines the type of the genome. Currently, AI::Genetic
supports only three types:
.RS 8
.IP "\fIbitvector\fR" 4
.IX Item "bitvector"
Individuals of this type have genes that are bits. Each gene
can be in one of two possible states, on or off.
.IP "\fIlistvector\fR" 4
.IX Item "listvector"
Each gene of a listvector individual can assume one string value from
a specified list of possible string values.
.IP "\fIrangevector\fR" 4
.IX Item "rangevector"
Each gene of a rangevector individual can assume one integer value
from a range of possible integer values. Note that only integers are
supported. The user can always transform any desired fractional values
by multiplying and dividing by an appropriate power of 10.
.RE
.RS 8
.Sp
Defaults to \fIbitvector\fR.
.RE
.IP "\fI\-terminate\fR" 8
.IX Item "-terminate"
This option allows the definition of a termination subroutine.
It expects a subroutine reference. This sub will be called at
the end of each generation with one argument: the AI::Genetic
object. Evolution terminates if the sub returns a true value.
.RE
.RS 4
.RE
.ie n .IP "\fI\fI$ga\fI\fR\->\fBcreateStrategy\fR(\fIstrategy_name\fR, \fIsub_ref\fR)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBcreateStrategy\fR(\fIstrategy_name\fR, \fIsub_ref\fR)" 4
.IX Item "$ga->createStrategy(strategy_name, sub_ref)"
This method allows the creation of a custom-made strategy to be used
during evolution. It expects a unique strategy name, and a subroutine
reference as arguments. The subroutine will be called with one argument:
the AI::Genetic object. It is expected to alter the population at each
generation. See \*(L"\s-1STRATEGIES\s0\*(R" for more information.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBinit\fR(\fIinitArgs\fR)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBinit\fR(\fIinitArgs\fR)" 4
.IX Item "$ga->init(initArgs)"
This method initializes the population with random individuals. It \fB\s-1MUST\s0\fR
be called before any call to \fI\fIevolve()\fI\fR or \fI\fIinject()\fI\fR. As a side effect,
any already existing individuals in the population are deleted. It expects
one argument, which depends on the type of individuals:
.RS 4
.IP "o" 4
.IX Item "o"
For bitvectors, the argument is simply the length of the bitvector.
.Sp
.Vb 1
\&    $ga\->init(10);
.Ve
.Sp
this initializes a population where each individual has 10 genes.
.IP "o" 4
.IX Item "o"
For listvectors, the argument is an anonymous list of lists. The
number of sub-lists is equal to the number of genes of each individual.
Each sub-list defines the possible string values that the corresponding gene
can assume.
.Sp
.Vb 5
\&    $ga\->init([
\&               [qw/red blue green/],
\&               [qw/big medium small/],
\&               [qw/very_fat fat fit thin very_thin/],
\&              ]);
.Ve
.Sp
this initializes a population where each individual has 3 genes, and each gene
can assume one of the given values.
.IP "o" 4
.IX Item "o"
For rangevectors, the argument is an anonymous list of lists. The
number of sub-lists is equal to the number of genes of each individual.
Each sub-list defines the minimum and maximum integer values that the
corresponding gene can assume.
.Sp
.Vb 5
\&    $ga\->init([
\&               [1, 5],
\&               [0, 20],
\&               [4, 9],
\&              ]);
.Ve
.Sp
this initializes a population where each individual has 3 genes, and each gene
can assume an integer within the corresponding range.
.RE
.RS 4
.RE
.ie n .IP "\fI\fI$ga\fI\fR\->\fBinject\fR(\fIN\fR, ?\fIargs\fR?)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBinject\fR(\fIN\fR, ?\fIargs\fR?)" 4
.IX Item "$ga->inject(N, ?args?)"
This method can be used to add more individuals to the population. New individuals
can be randomly generated, or be explicitly specified. The first argument specifies
the number, \fIN\fR, of new individuals to add. This can be followed by at most \fIN\fR
arguments, each of which is an anonymous list that specifies the genome of a
single individual to add. If the number of genomes given, \fIn\fR, is less than \fIN\fR, then
\&\fIN\fR \- \fIn\fR random individuals are added for a total of \fIN\fR new individuals. Random
individuals are generated using the same arguments passed to the \fI\fIinit()\fI\fR method.
For example:
.Sp
.Vb 4
\&  $ga\->inject(5,
\&              [qw/red big thin/],
\&              [qw/blue small fat/],
\&             );
.Ve
.Sp
this adds 5 new individuals, 2 with the specified genetic coding, and 3 randomly
generated.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBevolve\fR(\fIstrategy\fR, ?\fInum_generations\fR?)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBevolve\fR(\fIstrategy\fR, ?\fInum_generations\fR?)" 4
.IX Item "$ga->evolve(strategy, ?num_generations?)"
This method causes the \s-1GA\s0 to evolve the population using the specified strategy.
A strategy name has to be specified as the first argument. The second argument
is optional and specifies the number of generations to evolve. It defaults to
1. See \*(L"\s-1STRATEGIES\s0\*(R" for more information on the default strategies.
.Sp
Each generation consists of the following steps:
.RS 4
.IP "o" 4
.IX Item "o"
The population is sorted according to the individuals' fitnesses.
.IP "o" 4
.IX Item "o"
The subroutine corresponding to the named strategy is called with one argument,
the AI::Genetic object. This subroutine is expected to alter the object itself.
.IP "o" 4
.IX Item "o"
If a termination subroutine is given, it is executed and the return value is
checked. Evolution terminates if this sub returns a true value.
.RE
.RS 4
.RE
.ie n .IP "\fI\fI$ga\fI\fR\->\fBgetFittest\fR(?\fIN\fR?)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBgetFittest\fR(?\fIN\fR?)" 4
.IX Item "$ga->getFittest(?N?)"
This returns the \fIN\fR fittest individuals. If not specified,
\&\fIN\fR defaults to 1. As a side effect, it sorts the population by
fitness score. The actual AI::Genetic::Individual objects are returned.
You can use the \f(CW\*(C`genes()\*(C'\fR and \f(CW\*(C`score()\*(C'\fR methods to get the genes and the
scores of the individuals. Please check AI::Genetic::Individual for details.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBsortPopulation\fR" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBsortPopulation\fR" 4
.IX Item "$ga->sortPopulation"
This method sorts the population according to fitness function. The results
are cached for speed.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBsortIndividuals\fR(?[\fIListOfIndividuals\fR]?)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBsortIndividuals\fR(?[\fIListOfIndividuals\fR]?)" 4
.IX Item "$ga->sortIndividuals(?[ListOfIndividuals]?)"
Given an anonymous list of individuals, this method sorts them according
to fitness, returning an anonymous list of the sorted individuals.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBpeople\fR()" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBpeople\fR()" 4
.IX Item "$ga->people()"
Returns an anonymous list of individuals of the current population.
\&\fB\s-1IMPORTANT\s0\fR: the actual array reference used by the AI::Genetic object
is returned, so any changes to it will be reflected in \fI\f(CI$ga\fI\fR.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBsize\fR(?\fInewSize\fR?)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBsize\fR(?\fInewSize\fR?)" 4
.IX Item "$ga->size(?newSize?)"
This method is used to query and set the population size.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBcrossProb\fR(?\fInewProb\fR?)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBcrossProb\fR(?\fInewProb\fR?)" 4
.IX Item "$ga->crossProb(?newProb?)"
This method is used to query and set the crossover rate.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBmutProb\fR(?\fInewProb\fR?)" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBmutProb\fR(?\fInewProb\fR?)" 4
.IX Item "$ga->mutProb(?newProb?)"
This method is used to query and set the mutation rate.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBindType\fR()" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBindType\fR()" 4
.IX Item "$ga->indType()"
This method returns the type of individual: \fIbitvector\fR, \fIlistvector\fR,
or \fIrangevector\fR.
.ie n .IP "\fI\fI$ga\fI\fR\->\fBgeneration\fR()" 4
.el .IP "\fI\f(CI$ga\fI\fR\->\fBgeneration\fR()" 4
.IX Item "$ga->generation()"
This method returns the current generation.
.SH "FITNESS FUNCTION"
.IX Header "FITNESS FUNCTION"
Very quickly you will realize that properly defining the fitness function
is the most important aspect of a \s-1GA\s0. Most of the time that a genetic
algorithm takes to run is spent in running the fitness function for each
separate individual to get its fitness. AI::Genetic tries to minimize this
time by caching the fitness result for each individual. But, \fByou should
spend a lot of time optimizing your fitness function to achieve decent run
times.\fR
.PP
The fitness function should expect only one argument, an anonymous list of
genes, corresponding to the individual being analyzed. It is expected
to return a number which defines the fitness score of the said individual.
The higher the score, the more fit the individual, the more the chance it
has to be chosen for crossover.
.SH "STRATEGIES"
.IX Header "STRATEGIES"
AI::Genetic comes with 9 predefined strategies. These are:
.IP "rouletteSinglePoint" 4
.IX Item "rouletteSinglePoint"
This strategy implements roulette-wheel selection and single-point crossover.
.IP "rouletteTwoPoint" 4
.IX Item "rouletteTwoPoint"
This strategy implements roulette-wheel selection and two-point crossover.
.IP "rouletteUniform" 4
.IX Item "rouletteUniform"
This strategy implements roulette-wheel selection and uniform crossover.
.IP "tournamentSinglePoint" 4
.IX Item "tournamentSinglePoint"
This strategy implements tournament selection and single-point crossover.
.IP "tournamentTwoPoint" 4
.IX Item "tournamentTwoPoint"
This strategy implements tournament selection and two-point crossover.
.IP "tournamentUniform" 4
.IX Item "tournamentUniform"
This strategy implements tournament selection and uniform crossover.
.IP "randomSinglePoint" 4
.IX Item "randomSinglePoint"
This strategy implements random selection and single-point crossover.
.IP "randomTwoPoint" 4
.IX Item "randomTwoPoint"
This strategy implements random selection and two-point crossover.
.IP "randomUniform" 4
.IX Item "randomUniform"
This strategy implements random selection and uniform crossover.
.PP
More detail on these strategies and how to call them in your own
custom strategies can be found in AI::Genetic::OpSelection,
AI::Genetic::OpCrossover and AI::Genetic::OpMutation.
.PP
You can use the functions defined in the above modules in your
own custom-made strategy. Consult their manpages for more info.
A custom-made strategy can be defined using the \fI\fIstrategy()\fI\fR
method and is called at the beginning of each generation. The only
argument to it is the AI::Genetic object itself. Note that the
population at this point is sorted accoring to each individual's
fitness score. It is expected that the strategy sub will modify
the population stored in the AI::Genetic object. Here's the
pseudo-code of events:
.PP
.Vb 8
\&    for (1 .. num_generations) {
\&      sort population;
\&      call strategy_sub;
\&      if (termination_sub exists) {
\&        call termination_sub;
\&        last if returned true value;
\&      }
\&    }
.Ve
.SH "A NOTE ON SPEED/EFFICIENCY"
.IX Header "A NOTE ON SPEED/EFFICIENCY"
Genetic algorithms are inherently slow.
Perl can be pretty fast, but will never reach the speed of optimized
C code (at least my Perl coding will not). I wrote AI::Genetic mainly
for my own learning experience, but still tried to optimize it as
much as I can while trying to keep it as flexible as possible.
.PP
To do that, I resorted to some well-known tricks like passing a
reference of a long list instead of the list itself (for example,
when calling the fitness function, a reference of the gene list
is passed), and caching fitness scores (if you try to evaluate
the fitness of the same individual more than once, then the fitness
function will not be called, and the cached result is returned).
.PP
To help speed up your run times, you should pay special attention
to the design of your fitness function since this will be called once
for each unique individual in each generation. If you can shave off a
few clock cycles here and there, then it will be greatly magnified in
the total run time.
.SH "BUGS"
.IX Header "BUGS"
I have tested this module quite a bit, and even used it to solve a
work-related problem successfully. But, if you think you found a bug
then please let me know, and I promise to look at it.
.PP
Also, if you have any requests, comments or suggestions, then feel
free to email me.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Either the usual:
.PP
.Vb 3
\&    perl Makefile.PL
\&    make
\&    make install
.Ve
.PP
or just stick it somewhere in \f(CW@INC\fR where perl can find it. It is in pure Perl.
.SH "AUTHOR & CREDITS"
.IX Header "AUTHOR & CREDITS"
Written by Ala Qumsieh \fIaqumsieh@cpan.org\fR.
.PP
Special thanks go to John D. Porter and Oliver Smith for stimulating
discussions and great suggestions. Daniel Martin and Ivan Tubert-Brohman
uncovered various bugs and for this I'm grateful.
.SH "COPYRIGHTS"
.IX Header "COPYRIGHTS"
(c) 2003\-2005 Ala Qumsieh. All rights reserved.
This module is distributed under the same terms as Perl itself.
